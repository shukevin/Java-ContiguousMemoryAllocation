Kevin Shu CS450 p2

How to run the code:
	1. Type: "make" in the makefile's directory to utilize the makefile.
	
	2. Type: java Driver [file path] [mode 1-3] [out]
		Replace the bracketed text with the designated file path/mode/text
		The [out] is optional. [out] displays the final state of the memory space.
		
		Example: java Driver src/file.txt 1 out
			- The example above runs First-fit on the src/file.txt file and displays to system.out the final memory space.
			
		Example: java Driver src/file.txt 2
			- The example above runs Best-fit on src/file.txt file.
			
		Modes are:
			1 = First-fit
			2 = Best-fit
			3 = Worst-fit
			
		The [out] argument will print to system.out in a format similar to:
			[mode] mode
			--------------------------
			Final memory space:
			...
			reference: #
				start: #
				end: #
				allocated: T/F
				size: #
			...
		Any reference denoted by '-1' is considered to be unallocated memory(aka a 'hole').	
		

Explanation of implementation:

	Driver.java runs the program.
	
	Memory.java is an object that handles memory block management.
	
	Block.java is an object that holds information about a memory block (size, start/end point, reference, allocation)
	
	BlockLinkedList.java/Node.java acts as a linked list that contains each Block from Block.java.
	
	FileParse.java reads in a file and converts it into a list of Operation objects.
	
	Operation.java is an object that holds information about each operation(reference, operation, argument)
	
	A successful run of the program will go as follows:
		Driver.java is ran, and takes user arguments as input.
		The FileParse object will parse the file given in the arguments and return a list of Operation objects.
		The Memory object is initiated which creates a BlockLinkedList with an empty Block of the given size(1024).
		The Memory object takes the list of Operation objects and loops through each operation attempting to conduct memory allocation of the given mode.
		Upon allocation, a node of the BlockLinkedList will be added with the corresponding block information. The previously deallocated block node will
		adjust in size.
		Upon successful allocation/deallocation of objects, the Memory object will return true which prints "Success".
		
	In between memory allocation/deallocation calls, the merge() method of Memory will be called which goes through the linked list and merges
	any two consecutive unallocated references(noted by Operation.reference = -1).
		
	An error will occur when there is no valid space for an allocation, or if an invalid deallocation is made (deallocation on a non-existent
	reference)
	
	The program will output to system.err with an error message: 
		Failed | Reference: # | Bytes: #
		Fragmentation bytes: #
		
	Fragmentation bytes is calculated by looping through the linked list and adding the sizes of each unallocated reference(Operation.reference = -1).
	
Known Bugs:
	---
	Possible bug: I considered the deallocation of a no longer referenced block to be invalid. 
	For example:
		1 1 25
		2 2 1
		3 2 1
	A failed message will appear for reference 3:
		Failed | Reference: 3 | ERROR: Attempt to deallocate an unreferenced block(#)
		Fragmentation bytes: #
		
	The overview of the project noted to end when "any memory operation cannot be satisfied" but did not specify a message
	for a non-satisfied deallocation operation. I added this custom message since it made no sense to note "Bytes: #" for a deallocation
	operation. However, even though it is also somewhat irrelevant, I included the fragmentation bytes to this error message.
	If this is not intended to function this way, it is a bug. Given the vague project overview though, I considered this type
	of functionality to not be a bug.

	---
	Possible bug: I do not check for duplicate reference values. 
	If you were two add two references such as:
		1 1 25
		1 1 30
	and then try to deallocate it:
		2 2 1
	the deallocation would only deallocate the first reference of 1.
	The final block would then be:
		---deallocated 0-24
		---allocated 25-54  ref: 1
		---deallocated 55-1023
	I did not check for this since I consider this an invalid input test case. It is my assumption that the occurrence of:
		1 1 25
		1 1 30
	and similar formats would not happen. If this is intended to deallocate both references, this is a bug.
	Given the vague project overview though, I considered this type of functionality to not be a bug.
	(Note: The following will work as such:
		1 1 25
		2 2 1
		1 1 30
		---allocated 0-29 ref 1
		---deallocated 30-1023
	)
	---
	Possible bug: My code relies on a 'hole' reference being equal to -1.
	The current implementation assumes references in input files are not -1. If you were to allocate something with -1:
		-1 1 25
	this would create an erroneous output. Given the vague project overview though, I considered this type
	of functionality to not be a bug. This is especially due to the fact that the one test input file you gave us started
	references at '1' and incremented linearly. This is why I assumed the value of -1 would be safe for assigning to holes.

Aside:
	All of my 'known bugs' are uncertainties I had with the input file. Since the project description/shown test inputs were
	vague I created this program with the assumption that the input file would not try to do weird things. I assumed this
	because this project is testing us on how to handle memory management, and not how to handle seemingly invalid inputs.
	If any of the known bugs above are indeed bugs, I'd like to argue that they shouldn't be due to the extremely vague information
	provided on the input files. 

	